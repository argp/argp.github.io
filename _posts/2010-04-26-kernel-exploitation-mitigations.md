---
id: 241
title: FreeBSD kernel exploitation mitigations
author: argp
layout: post
guid: http://argp.gr/blog/?p=241
permalink: /2010/04/26/kernel-exploitation-mitigations/
aktt_notify_twitter:
  - no
categories:
  - exploitation
  - freebsd
  - kernel
  - research
  - security
tags:
  - exploitation
  - exploitation mitigation
  - freebsd
  - kernel
  - memory corruption protection
  - security
---
In my recent [Black Hat Europe 2010 talk][1] I gave an overview of the kernel exploitation prevention mechanisms that exist on FreeBSD. A few people at the conference have subsequently asked me to elaborate on the subject. In this post I will collect all the information from my talk and the various discussions I had in the Black Hat conference hallways.

Userland memory corruption protections (also known as exploitation mitigations) have made most of the generic exploitation approaches obsolete. This is true both on Windows and Unix-like operating systems. In order to successfully achieve arbitrary code execution from a vulnerable application nowadays a researcher needs to look to the memory layout and the code structure of the particular application.

On the other hand, exploitation mitigation mechanisms for kernel code have not seen the same level of adoption mostly due to the performance penalty they introduce. This has increased the interest in viewing the operating system kernel as part of the attack surface targeted in a penetration test. Therefore, many operating systems have started to introduce kernel exploitation mitigations. The [recent CanSecWest talk][2] by Tavis Ormandy and Julien Tinnes titled &#8220;There&#8217;s a party at Ring0, and you&#8217;re invited&#8221; presented an overview of such mitigations on Windows and Linux.

FreeBSD also has a number of memory corruption protections for kernel code. Not all of these were developed with the goal of undermining attacks, but primarily as debugging mechanisms. Some are enabled by default in the latest stable version (8.0-RELEASE) and some are not.

### Stack-smashing

Kernel stack-smashing protection for FreeBSD was introduced in version 8.0 via [ProPolice/SSP][3]. Specifically, the file `src/sys/kern/stack_protector.c` is compiled with gcc&#8217;s `-fstack-protector` option and registers an event handler called `__stack_chk_init` that generates a random canary value (the &#8220;guard&#8221; variable in SSP terminology) placed between the local variables and the saved frame pointer of a kernel process’s stack during a function’s prologue. Below is the relevant part of the `stack_protector.c` file:

<div class="wp_syntax">
  <table>
    <tr>
      <td class="code">
        <pre class="c" style="font-family:monospace;"><span style="color: #0000dd;">10</span><span style="color: #339933;">:</span> __stack_chk_guard<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">8</span><span style="color: #009900;">&#93;</span> <span style="color: #339933;">=</span> <span style="color: #009900;">&#123;</span><span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>
    ...
<span style="color: #0000dd;">20</span><span style="color: #339933;">:</span> <span style="color: #339933;">#define __arraycount(__x)       (sizeof(__x) / sizeof(__x[0]))</span>
<span style="color: #0000dd;">21</span><span style="color: #339933;">:</span> <span style="color: #993333;">static</span> <span style="color: #993333;">void</span>
<span style="color: #0000dd;">22</span><span style="color: #339933;">:</span> __stack_chk_init<span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span> <span style="color: #339933;">*</span>dummy __unused<span style="color: #009900;">&#41;</span>
<span style="color: #0000dd;">23</span><span style="color: #339933;">:</span> <span style="color: #009900;">&#123;</span>
<span style="color: #0000dd;">24</span><span style="color: #339933;">:</span>         <span style="color: #993333;">size_t</span> i<span style="color: #339933;">;</span>
<span style="color: #0000dd;">25</span><span style="color: #339933;">:</span>         <span style="color: #993333;">long</span> guard<span style="color: #009900;">&#91;</span>__arraycount<span style="color: #009900;">&#40;</span>__stack_chk_guard<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
<span style="color: #0000dd;">26</span><span style="color: #339933;">:</span> 
<span style="color: #0000dd;">27</span><span style="color: #339933;">:</span>         arc4rand<span style="color: #009900;">&#40;</span>guard<span style="color: #339933;">,</span> <span style="color: #993333;">sizeof</span><span style="color: #009900;">&#40;</span>guard<span style="color: #009900;">&#41;</span><span style="color: #339933;">,</span> <span style="color: #0000dd;"></span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #0000dd;">28</span><span style="color: #339933;">:</span>         <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>i <span style="color: #339933;">=</span> <span style="color: #0000dd;"></span><span style="color: #339933;">;</span> i <span style="color: #339933;">&lt;</span> __arraycount<span style="color: #009900;">&#40;</span>guard<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span> i<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span>
<span style="color: #0000dd;">29</span><span style="color: #339933;">:</span>                 __stack_chk_guard<span style="color: #009900;">&#91;</span>i<span style="color: #009900;">&#93;</span> <span style="color: #339933;">=</span> guard<span style="color: #009900;">&#91;</span>i<span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
<span style="color: #0000dd;">30</span><span style="color: #339933;">:</span> <span style="color: #009900;">&#125;</span></pre>
      </td>
    </tr>
  </table>
</div>

During the protected function&#8217;s epilogue the canary is checked against its original value. If it has been altered the kernel calls [`panic(9)`][4] bringing down the whole system, but also stopping any execution flow redirection caused by manipulation of the function’s saved frame pointer or saved return address (again from the `stack_protector.c` file):

<div class="wp_syntax">
  <table>
    <tr>
      <td class="code">
        <pre class="c" style="font-family:monospace;"><span style="color: #0000dd;">13</span><span style="color: #339933;">:</span> <span style="color: #993333;">void</span>
<span style="color: #0000dd;">14</span><span style="color: #339933;">:</span> __stack_chk_fail<span style="color: #009900;">&#40;</span><span style="color: #993333;">void</span><span style="color: #009900;">&#41;</span>
<span style="color: #0000dd;">15</span><span style="color: #339933;">:</span> <span style="color: #009900;">&#123;</span>
<span style="color: #0000dd;">16</span><span style="color: #339933;">:</span> 
<span style="color: #0000dd;">17</span><span style="color: #339933;">:</span>         panic<span style="color: #009900;">&#40;</span><span style="color: #ff0000;">"stack overflow detected; backtrace may be corrupted"</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #0000dd;">18</span><span style="color: #339933;">:</span> <span style="color: #009900;">&#125;</span></pre>
      </td>
    </tr>
  </table>
</div>

ProPolice/SSP also performs local variable and pointer reordering in order to protect against the corruption of variables and pointers due to stack buffer overflow vulnerabilities. 

### NULL page mappings

Also in version 8.0, FreeBSD has [introduced a protection][5] against user mappings at address 0 (NULL). This exploitation mitigation mechanism is exposed through the [`sysctl(8)`][6] variable `security.bsd.map_at_zero` and is enabled by default (i.e. the variable has the value 0). When a user request is made for the NULL page and the feature is enabled an error occurs and the mapping fails. Obviously this protection is ineffective in vulnerabilities which the attacker can (directly or indirectly) control the kernel dereference offset. For an applicable example see the exploit for vulnerability CVE-2008-3531 I have previously [published][7].

### Heap-smashing

FreeBSD has introduced kernel heap-smashing detection in 8.0-RELEASE via an implementation  
called [RedZone][8]. RedZone is oriented more towards debugging the kernel memory allocator rather than detecting and stopping deliberate attacks against it. If enabled (it is disabled by default) RedZone places a static canary value of 16 bytes above and below each buffer allocated on the heap. The canary value consists of the hexadecimal value 0x42 repeated in these 16 bytes.

During a heap buffer&#8217;s deallocation the canary value is checked and if it has been corrupted the details of the corruption (address of the offending buffer and stack traces of the buffer&#8217;s allocation and deallocation) are logged. The code that performs the check for a heap overflow is the following (from file `src/sys/vm/redzone.c`):

<div class="wp_syntax">
  <table>
    <tr>
      <td class="code">
        <pre class="c" style="font-family:monospace;"><span style="color: #0000dd;">166</span><span style="color: #339933;">:</span> ncorruptions <span style="color: #339933;">=</span> <span style="color: #0000dd;"></span><span style="color: #339933;">;</span>
<span style="color: #0000dd;">167</span><span style="color: #339933;">:</span> <span style="color: #b1b100;">for</span> <span style="color: #009900;">&#40;</span>i <span style="color: #339933;">=</span> <span style="color: #0000dd;"></span><span style="color: #339933;">;</span> i <span style="color: #339933;">&lt;</span> REDZONE_CFSIZE<span style="color: #339933;">;</span> i<span style="color: #339933;">++,</span> faddr<span style="color: #339933;">++</span><span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#123;</span>
<span style="color: #0000dd;">168</span><span style="color: #339933;">:</span>       <span style="color: #b1b100;">if</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span><span style="color: #009900;">&#40;</span>u_char <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span>faddr <span style="color: #339933;">!=</span> <span style="color: #208080;">0x42</span><span style="color: #009900;">&#41;</span>
<span style="color: #0000dd;">169</span><span style="color: #339933;">:</span>               ncorruptions<span style="color: #339933;">++;</span>
<span style="color: #0000dd;">170</span><span style="color: #339933;">:</span> <span style="color: #009900;">&#125;</span></pre>
      </td>
    </tr>
  </table>
</div>

This protection mechanism can obviously be easily bypassed. 

### Use-after-free

[MemGuard][9] is a replacement kernel memory allocator introduced in FreeBSD version 6.0 and is designed to detect use-after-free bugs in kernel code. Similarly to RedZone, MemGuard mainly targets debugging scenarios and does not constitute a mechanism to mitigate deliberate attacks. However, MemGuard is not compatible and cannot replace the Universal Memory Allocator&#8217;s (UMA &#8211; which is the default kernel allocator in FreeBSD) calls. Therefore (and also due to the overhead it introduced even before UMA was developed), it is not enabled by default.

 [1]: http://www.blackhat.com/html/bh-eu-10/bh-eu-10-archives.html#Argyroudis
 [2]: http://www.cr0.org/paper/to-jt-party-at-ring0.pdf
 [3]: http://www.trl.ibm.com/projects/security/ssp/
 [4]: http://www.freebsd.org/cgi/man.cgi?query=panic&#038;apropos=0&#038;sektion=9&#038;manpath=FreeBSD+8.0-RELEASE&#038;format=html
 [5]: http://security.freebsd.org/advisories/FreeBSD-EN-09:05.null.asc
 [6]: http://www.freebsd.org/cgi/man.cgi?query=sysctl&#038;apropos=0&#038;sektion=8&#038;manpath=FreeBSD+8.0-RELEASE&#038;format=html
 [7]: http://census-labs.com/news/2009/07/02/cve-2008-3531-exploit/
 [8]: http://fxr.watson.org/fxr/source/vm/redzone.c
 [9]: http://www.freebsd.org/cgi/man.cgi?query=memguard&#038;apropos=0&#038;sektion=9&#038;manpath=FreeBSD+8.0-RELEASE&#038;format=html