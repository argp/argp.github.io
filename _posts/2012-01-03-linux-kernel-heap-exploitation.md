---
title: The Linux kernel memory allocators from an exploitation perspective
layout: post
tags:
  - exploitation
  - heap
  - kernel
  - linux
  - slab
  - slob
  - slub
---
In anticipation of [Dan Rosenberg's](https://twitter.com/djrbliss)
talk on exploiting the Linux kernel's SLOB memory allocator at the
[Infiltrate security conference](http://immunityinc.com/infiltrate/)
and because I recently had a discussion with some friends about the different
kernel memory allocators in Linux, I decided to write this quick introduction.
I will present some of the allocators' characteristics and also provide
references to public work on exploitation techniques.

<p align="center">
<img src="/public/slabs.jpg" width="300" height="225"/>
</p>

At the time of this writing, the Linux kernel has three different memory
allocators in the official code tree, namely SLAB, SLUB and SLOB. These
allocators are on a memory management layer that is logically on top of the
system's low level page allocator and are mutually exclusive (i.e. you
can only have one of them enabled/compiled in your kernel). They are used when
a kernel developer calls `kmalloc()` or a similar function. Unsurprisingly,
they can all be found in the
[mm directory](http://lxr.linux.no/linux+v3.1.6/mm/). All of them follow, to
various extends and by extending or simplifying, the [traditional slab allocator
design](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4759) (notice
the lowercase "slab"; that's the term for the general allocator design approach,
while "SLAB" is a slab implementation in the Linux kernel). Slab allocators
allocate prior to any request, for example at kernel boot time, large areas of
virtual memory (called "slabs", hence the name). Each one of these slabs is then
 associated to a kernel structure of a specific type and size. Furthermore, each
slab is divided into the appropriate number of slots for the size of the kernel
structure it is associated with. As an example consider that a slab for the
structure `task_struct` has 31 slots. The size of a `task_struct` is 1040
bytes, so assuming that a page is 4096 bytes (the default) then a `task_struct`
slab is 8 pages long. Apart from the structure-specific slabs, like the one
above for `task_struct`, there are also the so called general purpose slabs
which are used to serve arbitrary-sized `kmalloc()` requests. These requests
are adjusted by the allocator for alignment and assigned to a suitable slab.

Let's take a look at the slabs of a recent Linux kernel:

```
$ cat /proc/slabinfo
slabinfo - version: 2.1
...
fat_inode_cache       57     57    416   19    2 : tunables             : slabdata      3      3      
fat_cache            170    170     24  170    1 : tunables             : slabdata      1      1      
VMBlockInodeCache      7      7   4480    7    8 : tunables             : slabdata      1      1      
blockInfoCache                    4160    7    8 : tunables             : slabdata                  
AF_VMCI                            704   23    4 : tunables             : slabdata                  
fuse_request          80     80    400   20    2 : tunables             : slabdata      4      4      
fuse_inode         21299  21690    448   18    2 : tunables             : slabdata   1205   1205      
...
kmalloc-8192          94     96   8192    4    8 : tunables             : slabdata     24     24      
kmalloc-4096         118    128   4096    8    8 : tunables             : slabdata     16     16      
kmalloc-2048         173    208   2048   16    8 : tunables             : slabdata     13     13      
kmalloc-1024         576    640   1024   16    4 : tunables             : slabdata     40     40      
kmalloc-512          904    992    512   16    2 : tunables             : slabdata     62     62      
kmalloc-256          540    976    256   16    1 : tunables             : slabdata     61     61      
kmalloc-128          946   1408    128   32    1 : tunables             : slabdata     44     44      
kmalloc-64         13013  13248     64   64    1 : tunables             : slabdata    207    207      
kmalloc-32         23624  27264     32  128    1 : tunables             : slabdata    213    213      
kmalloc-16          3546   3584     16  256    1 : tunables             : slabdata     14     14      
kmalloc-8           4601   4608      8  512    1 : tunables             : slabdata      9      9      
kmalloc-192         3659   4620    192   21    1 : tunables             : slabdata    220    220      
kmalloc-96         10137  11340     96   42    1 : tunables             : slabdata    270    270      
kmem_cache            32     32    128   32    1 : tunables             : slabdata      1      1      
kmem_cache_node      256    256     32  128    1 : tunables             : slabdata      2      2      
```

Here you can see structure-specific slabs, for example `fuse_inode`, and
general purpose slabs, for example `kmalloc-96`.

When it comes to the exploitation of overflow bugs in the context of slab
allocators, there are three general approaches to corrupt kernel memory:

  * Corruption of the adjacent objects/structures of the same slab.
  * Corruption of the slab allocator&#8217;s management structures
    (referred to as *metadata*).
  * Corruption of the adjacent *physical* page of the slab your vulnerable
    structure is allocated on.

The ultimate goal of the above approaches is of course to gain
control of the kernel&#8217;s execution flow and divert/hijack it to your own
code. In order to be able to manipulate the allocator and the state of its
slabs, arranging structures on them to your favor (i.e. next to each other on
the same slab, or at the end of a slab), it is nice (but not strictly required
;) to have some information on the allocator&#8217;s state. The proc filesystem
provides us with a way to get this information. Unprivileged local users can
simply `cat /proc/slabinfo` (as shown above) and see the allocator&#8217;s
slabs, the number of used/free structures on them, etc. [Is your distribution
still allowing this?][6]

For each one of the Linux kernel&#8217;s allocators I will provide
references to papers describing practical attack techniques and examples of
public exploits.

### SLAB

Starting with the oldest of the three allocators, [SLAB][7]
organizes physical memory frames in caches. Each cache is responsible for a
specific kernel structure. Also, each cache holds slabs that consist of
contiguous pages and these slabs are responsible for the actual storing of the
kernel structures of the cache&#8217;s type. A SLAB&#8217;s slab can have both
allocated (in use) and deallocated (free) slots. Based on this and with the
goal of reducing fragmentation of the system&#8217;s virtual memory, a
cache&#8217;s slabs are divided into three lists; a list with full slabs (i.e
slabs with no free slots), a list with empty slabs (slabs on which all slots
are free), and a list with partial slabs (slabs that have slots both in use and
free).

A SLAB&#8217;s slab is described by the following structure:

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #993333;">struct</span> slab
<span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">union</span>
    <span style="color: #009900;">&#123;</span>
        <span style="color: #993333;">struct</span>
        <span style="color: #009900;">&#123;</span>
            <span style="color: #993333;">struct</span> list_head list<span
style="color: #339933;">;</span>
            <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">long</span> colouroff<span style="color: #339933;">;</span>
            <span style="color: #993333;">void</span> <span style="color:
#339933;">*</span>s_mem<span style="color: #339933;">;</span>            <span
style="color: #808080; font-style: italic;">/* including colour offset */</span>
            <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">int</span> inuse<span style="color: #339933;">;</span>     <span
style="color: #808080; font-style: italic;">/* num of objs active in slab
*/</span>
            kmem_bufctl_t <span style="color: #000066;">free</span><span
style="color: #339933;">;</span>
            <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">short</span> nodeid<span style="color: #339933;">;</span>
        <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
        <span style="color: #993333;">struct</span> slab_rcu
__slab_cover_slab_rcu<span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
<span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

The `list` variable is used to place the slab in one of the lists I
described above. Coloring and the variable `colouroff` require some explanation
in case you haven&#8217;t seen them before. Coloring or cache coloring is a
performance trick to reduce processor L1 cache hits. This is accomplished by
making sure that the first &#8220;slot&#8221; of a slab (which is used to store
the slab&#8217;s `slab` structure, i.e. the slab&#8217;s metadata) is not
placed at the beginning of the slab (which is also at the start of a page) but
an offset `colouroff` from it. `s_mem` is a pointer to the first slot of the
slab that stores an actual kernel structure/object. `free` is an index to the
next free object of the slab.

As I mentioned in the previous paragraph, a SLAB&#8217;s slab
begins with a `slab` structure (the slab&#8217;s metadata) and is followed by
the slab&#8217;s objects. The stored objects on a slab are contiguous, with no
metadata in between them, making easier the exploitation approach of corrupting
adjacent objects. Easier means that when we overflow from one object to its
adjacent we don&#8217;t corrupt management data that could lead to making the
system crash.

By manipulating SLAB through controlled allocations and
deallocations from userland that affect the kernel (for example via system
calls) we can arrange that the overflow from a vulnerable structure will
corrupt an adjacent structure of our own choosing. The fact that SLAB&#8217;s
allocations and deallocations work in a LIFO manner is of course to our
advantage in arranging structures/objects on the slabs. As qobaiashi has
presented in his paper [&#8220;The story of exploiting kmalloc()
overflows&#8221;][8], the system calls `semget()` and `semctl(..., ...,
IPC_RMID)` is one way to make controlled allocations and deallocations
respectively. The term &#8220;controlled&#8221; here refers to both the size of
the allocation/deallocation and the fact that we can use them directly from
userland. Another requirement that these system calls satisfy is that the
structure they allocate can help us in our quest for code execution when used
as a victim object and corrupted from a vulnerable object. Other ways/system
calls that satisfy all the above requirements do exist.

Another resource on attacking SLAB is &#8220;Exploiting kmalloc
overflows to 0wn j00&#8243; by amnesia and clflush. In that presentation the
authors explained the development process for a reliable exploit for
vulnerability [CVE-2004-0424][9] (which was an integer overflow leading to a
kernel heap buffer overflow found by ihaquer and cliph). Both the presentation
and the exploit are not public as far as I know. However, a full exploit was
published by twiz and sgrakkyu in [Phrack #64][10] (castity.c).

### SLUB

[SLUB][11] is currently the default allocator of the Linux kernel.
It follows the SLAB allocator I have already described in its general design
(caches, slabs, full/empty/partial lists of slabs, etc.), however it has
introduced simplifications in respect to management overhead to achieve better
performance. One of the main differences is that SLUB has no metadata at the
beginning of each slab like SLAB, but instead it has added it&#8217;s metadata
variables in the Linux kernel&#8217;s `page` structure to track the
allocator&#8217;s data on the physical pages.

The following excerpt includes only the relevant parts of the
`page` structure, see [here][12] for the complete version.

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #993333;">struct</span> page
<span style="color: #009900;">&#123;</span>
    ...
&nbsp;
    <span style="color: #993333;">struct</span>
    <span style="color: #009900;">&#123;</span>
        <span style="color: #993333;">union</span>
        <span style="color: #009900;">&#123;</span>
            pgoff_t index<span style="color: #339933;">;</span>          <span
style="color: #808080; font-style: italic;">/* Our offset within mapping.
*/</span>
            <span style="color: #993333;">void</span> <span style="color:
#339933;">*</span>freelist<span style="color: #339933;">;</span>         <span
style="color: #808080; font-style: italic;">/* slub first free object */</span>
        <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
        ...
&nbsp;
        <span style="color: #993333;">struct</span>
        <span style="color: #009900;">&#123;</span>
            <span style="color: #993333;">unsigned</span> inuse<span
style="color: #339933;">:</span><span style="color: #0000dd;">16</span><span
style="color: #339933;">;</span>
            <span style="color: #993333;">unsigned</span> objects<span
style="color: #339933;">:</span><span style="color: #0000dd;">15</span><span
style="color: #339933;">;</span>
            <span style="color: #993333;">unsigned</span> frozen<span
style="color: #339933;">:</span><span style="color: #0000dd;">1</span><span
style="color: #339933;">;</span>
        <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
        ...
    <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
    ...
&nbsp;
    <span style="color: #993333;">union</span>
    <span style="color: #009900;">&#123;</span>
        ...
        <span style="color: #993333;">struct</span> kmem_cache <span
style="color: #339933;">*</span>slab<span style="color: #339933;">;</span>      
  <span style="color: #808080; font-style: italic;">/* SLUB: Pointer to slab
*/</span>  
        ...
    <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
    ...
<span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

Since there are no metadata on the slab itself, a `page`&#8216;s
`freelist` pointer is used to point to the first free object of the slab. A
free object of a slab has a small header with metadata that contain a pointer
to the next free object of the slab. The `index` variable holds the offset to
these metadata within a free object. `inuse` and `objects` hold respectively
the allocated and total number of objects of the slab. `frozen` is a flag that
specifies whether the page can be used by SLUB&#8217;s list management
functions. Specifically, if a page has been frozen by a CPU core, only this
core can retrieve free objects from the page, while the other available CPU
cores can only add free objects to it. The last interesting for our discussion
variable is `slab` which is of type `struct kmem_cache` and is a pointer to the
slab on the page.

The function `on_freelist()` is used by SLUB to determine if a
given object is on a given page&#8217;s `freelist` and provides a nice
introduction to the use of the above elements. The following snippet is an
example invocation of `on_freelist()` (taken from [here][13]):

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c"
style="font-family:monospace;">slab_lock<span style="color:
#009900;">&#40;</span>page<span style="color: #009900;">&#41;</span><span
style="color: #339933;">;</span>
&nbsp;
<span style="color: #b1b100;">if</span><span style="color:
#009900;">&#40;</span>on_freelist<span style="color:
#009900;">&#40;</span>page<span style="color: #339933;">-&gt;</span>slab<span
style="color: #339933;">,</span> page<span style="color: #339933;">,</span>
object<span style="color: #009900;">&#41;</span><span style="color:
#009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
    object_err<span style="color: #009900;">&#40;</span>page<span style="color:
#339933;">-&gt;</span>slab<span style="color: #339933;">,</span> page<span
style="color: #339933;">,</span> object<span style="color: #339933;">,</span>
<span style="color: #ff0000;">"Object is on free-list"</span><span
style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
    rv <span style="color: #339933;">=</span> <span style="color: #000000;
font-weight: bold;">false</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
<span style="color: #b1b100;">else</span>
<span style="color: #009900;">&#123;</span>
    rv <span style="color: #339933;">=</span> <span style="color: #000000;
font-weight: bold;">true</span><span style="color: #339933;">;</span>
<span style="color: #009900;">&#125;</span>
&nbsp;
slab_unlock<span style="color: #009900;">&#40;</span>page<span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

Locking is required to avoid inconsistencies since `on_freelist()`
makes some modifications and it could be interrupted. Let&#8217;s take a look
at an excerpt from `on_freelist()` (the full version is [here][14]):

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #993333;">static</span> <span style="color: #993333;">int</span>
on_freelist<span style="color: #009900;">&#40;</span><span style="color:
#993333;">struct</span> kmem_cache <span style="color: #339933;">*</span>s<span
style="color: #339933;">,</span> <span style="color: #993333;">struct</span>
page <span style="color: #339933;">*</span>page<span style="color:
#339933;">,</span> <span style="color: #993333;">void</span> <span
style="color: #339933;">*</span>search<span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">int</span> nr <span style="color:
#339933;">=</span> <span style="color: #0000dd;"></span><span style="color:
#339933;">;</span>
    <span style="color: #993333;">void</span> <span style="color:
#339933;">*</span>fp<span style="color: #339933;">;</span>
    <span style="color: #993333;">void</span> <span style="color:
#339933;">*</span>object <span style="color: #339933;">=</span> NULL<span
style="color: #339933;">;</span>
    <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">long</span> max_objects<span style="color: #339933;">;</span>
&nbsp;
    fp <span style="color: #339933;">=</span> page<span style="color:
#339933;">-&gt;</span>freelist<span style="color: #339933;">;</span>
    <span style="color: #b1b100;">while</span><span style="color:
#009900;">&#40;</span>fp <span style="color: #339933;">&&</span> nr <span
style="color: #339933;">&lt;=</span> page<span style="color:
#339933;">-&gt;</span>objects<span style="color: #009900;">&#41;</span>
    <span style="color: #009900;">&#123;</span>
        <span style="color: #b1b100;">if</span><span style="color:
#009900;">&#40;</span>fp <span style="color: #339933;">==</span> search<span
style="color: #009900;">&#41;</span>
            <span style="color: #b1b100;">return</span> <span style="color:
#0000dd;">1</span><span style="color: #339933;">;</span>
        <span style="color: #b1b100;">if</span><span style="color:
#009900;">&#40;</span><span style="color:
#339933;">!</span>check_valid_pointer<span style="color:
#009900;">&#40;</span>s<span style="color: #339933;">,</span> page<span
style="color: #339933;">,</span> fp<span style="color:
#009900;">&#41;</span><span style="color: #009900;">&#41;</span>
        <span style="color: #009900;">&#123;</span>
            <span style="color: #b1b100;">if</span><span style="color:
#009900;">&#40;</span>object<span style="color: #009900;">&#41;</span>
            <span style="color: #009900;">&#123;</span>
                object_err<span style="color: #009900;">&#40;</span>s<span
style="color: #339933;">,</span> page<span style="color: #339933;">,</span>
object<span style="color: #339933;">,</span> <span style="color:
#ff0000;">"Freechain corrupt"</span><span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span>
                set_freepointer<span style="color: #009900;">&#40;</span>s<span
style="color: #339933;">,</span> object<span style="color: #339933;">,</span>
NULL<span style="color: #009900;">&#41;</span><span style="color:
#339933;">;</span>
                <span style="color: #000000; font-weight:
bold;">break</span><span style="color: #339933;">;</span>
            <span style="color: #009900;">&#125;</span>
            <span style="color: #b1b100;">else</span>
            <span style="color: #009900;">&#123;</span>
                slab_err<span style="color: #009900;">&#40;</span>s<span
style="color: #339933;">,</span> page<span style="color: #339933;">,</span>
<span style="color: #ff0000;">"Freepointer corrupt"</span><span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span>
                page<span style="color: #339933;">-&gt;</span>freelist <span
style="color: #339933;">=</span> NULL<span style="color: #339933;">;</span>
                page<span style="color: #339933;">-&gt;</span>inuse <span
style="color: #339933;">=</span> page<span style="color:
#339933;">-&gt;</span>objects<span style="color: #339933;">;</span>
                slab_fix<span style="color: #009900;">&#40;</span>s<span
style="color: #339933;">,</span> <span style="color: #ff0000;">"Freelist
cleared"</span><span style="color: #009900;">&#41;</span><span style="color:
#339933;">;</span>
                <span style="color: #b1b100;">return</span> <span style="color:
#0000dd;"></span><span style="color: #339933;">;</span>
            <span style="color: #009900;">&#125;</span>
&nbsp;
            <span style="color: #000000; font-weight: bold;">break</span><span
style="color: #339933;">;</span>
        <span style="color: #009900;">&#125;</span>
&nbsp;
        object <span style="color: #339933;">=</span> fp<span style="color:
#339933;">;</span>
        fp <span style="color: #339933;">=</span> get_freepointer<span
style="color: #009900;">&#40;</span>s<span style="color: #339933;">,</span>
object<span style="color: #009900;">&#41;</span><span style="color:
#339933;">;</span>
        nr<span style="color: #339933;">++;</span>
    <span style="color: #009900;">&#125;</span>
&nbsp;
    ...
<span style="color: #009900;">&#125;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

The function starts with a simple piece of code that walks the
`freelist` and demonstrates the use of SLUB internal variables. Of particular
interest is the call of the `check_valid_pointer()` function which verifies
that a `freelist`&#8216;s object&#8217;s address (variable `fp`) is within a
slab page. This is a check that safeguards against corruptions of the
`freelist`.

This brings us to attacks against the SLUB memory allocator. The
attack vector of corrupting adjacent objects on the same slab is fully
applicable to SLUB and largely works like in the case of the SLAB allocator.
However, in the case of SLUB there is an added attack vector: exploiting the
allocator&#8217;s metadata (the ones responsible for finding the next free
object on the slab). As twiz and sgrakkyu have demonstrated in [their book on
kernel exploitation][15], the slab can be misaligned by corrupting the least
significant byte of the metadata of a free object that hold the pointer to the
next free object. This misalignment of the slab allows us to create an in-slab
fake object and by doing so to a) satisfy safeguard checks as the one I
explained in the previous paragraph when they are used, and b) to hijack the
kernel&#8217;s execution flow to our own code.

An example of SLUB metadata corruption and slab misalignment is the
exploit for vulnerability [CVE-2009-1046][16] which was an off-by-two kernel
heap overflow. In [this blog post][17], sgrakkyu explained how by using only an
one byte overflow turned this vulnerability into a reliable exploit
(tiocl_houdini.c). If you&#8217;re wondering why an one byte overflow is more
reliable than a two byte overflow think about little-endian representation.

A public example of corrupting adjacent SLUB objects is the exploit
i-can-haz-modharden.c by Jon Oberheide for vulnerability [CVE-2010-2959][18]
discovered by Ben Hawkes. In [this blog post][19] you can find an overview of
the exploit and the technique.

### SLOB

Finally, [SLOB][20] is a stripped down kernel allocator
implementation designed for systems with limited amounts of memory, for example
embedded versions/distributions of Linux. In fact its design is closer to
traditional userland memory allocators rather than the slab allocators SLAB and
SLUB. SLOB places all objects/structures on pages arranged in three linked
lists, for small, medium and large allocations. Small are the allocations of
size less than `SLOB_BREAK1` (256 bytes), medium those less than `SLOB_BREAK2`
(1024 bytes), and large are all the other allocations:

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #339933;">#define SLOB_BREAK1 256</span>
<span style="color: #339933;">#define SLOB_BREAK2 1024</span>
<span style="color: #993333;">static</span> LIST_HEAD<span style="color:
#009900;">&#40;</span>free_slob_small<span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">static</span> LIST_HEAD<span style="color:
#009900;">&#40;</span>free_slob_medium<span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span>
<span style="color: #993333;">static</span> LIST_HEAD<span style="color:
#009900;">&#40;</span>free_slob_large<span style="color:
#009900;">&#41;</span><span style="color: #339933;">;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

Of course this means that in SLOB we can have objects/structures of
different types and sizes on the same page. This is the main difference between
SLOB and SLAB/SLUB. A SLOB page is defined as follows:

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #993333;">struct</span> slob_page
<span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">union</span>
    <span style="color: #009900;">&#123;</span>
        <span style="color: #993333;">struct</span>
        <span style="color: #009900;">&#123;</span>
            <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">long</span> flags<span style="color: #339933;">;</span>    <span
style="color: #808080; font-style: italic;">/* mandatory */</span>
            atomic_t _count<span style="color: #339933;">;</span>        <span
style="color: #808080; font-style: italic;">/* mandatory */</span>
            slobidx_t units<span style="color: #339933;">;</span>        <span
style="color: #808080; font-style: italic;">/* free units left in page */</span>
            <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">long</span> pad<span style="color: #009900;">&#91;</span><span
style="color: #0000dd;">2</span><span style="color: #009900;">&#93;</span><span
style="color: #339933;">;</span>
            slob_t <span style="color: #339933;">*</span><span style="color:
#000066;">free</span><span style="color: #339933;">;</span>           <span
style="color: #808080; font-style: italic;">/* first free slob_t in page
*/</span>
            <span style="color: #993333;">struct</span> list_head list<span
style="color: #339933;">;</span>  <span style="color: #808080; font-style:
italic;">/* linked list of free pages */</span>
        <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
&nbsp;
        <span style="color: #993333;">struct</span> page page<span
style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span>
<span style="color: #009900;">&#125;</span><span style="color:
#339933;">;</span></pre>
                  </td>
                </tr>
              </table>
            </div>

The function `slob_alloc()` is SLOB&#8217;s main allocation routine
and based on the requested size it walks the appropriate list trying to find if
a page of the list has enough room to accommodate the new object/structure (the
full function is [here][21]):

            <div class="wp_syntax">
              <table>
                <tr>
                  <td class="code">
                    <pre class="c" style="font-family:monospace;"><span
style="color: #993333;">static</span> <span style="color: #993333;">void</span>
<span style="color: #339933;">*</span>slob_alloc<span style="color:
#009900;">&#40;</span><span style="color: #993333;">size_t</span> size<span
style="color: #339933;">,</span> gfp_t gfp<span style="color:
#339933;">,</span> <span style="color: #993333;">int</span> align<span
style="color: #339933;">,</span> <span style="color: #993333;">int</span>
node<span style="color: #009900;">&#41;</span>
<span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">struct</span> slob_page <span style="color:
#339933;">*</span>sp<span style="color: #339933;">;</span>
    <span style="color: #993333;">struct</span> list_head <span style="color:
#339933;">*</span>prev<span style="color: #339933;">;</span>
    <span style="color: #993333;">struct</span> list_head <span style="color:
#339933;">*</span>slob_list<span style="color: #339933;">;</span>
    slob_t <span style="color: #339933;">*</span>b <span style="color:
#339933;">=</span> NULL<span style="color: #339933;">;</span>
    <span style="color: #993333;">unsigned</span> <span style="color:
#993333;">long</span> flags<span style="color: #339933;">;</span>
&nbsp;
    <span style="color: #b1b100;">if</span> <span style="color:
#009900;">&#40;</span>size <span style="color: #339933;">&lt;</span>
SLOB_BREAK1<span style="color: #009900;">&#41;</span>
        slob_list <span style="color: #339933;">=</span> <span style="color:
#339933;">&</span>free_slob_small<span style="color: #339933;">;</span>
    <span style="color: #b1b100;">else</span> <span style="color:
#b1b100;">if</span> <span style="color: #009900;">&#40;</span>size <span
style="color: #339933;">&lt;</span> SLOB_BREAK2<span style="color:
#009900;">&#41;</span>
        slob_list <span style="color: #339933;">=</span> <span style="color:
#339933;">&</span>free_slob_medium<span style="color: #339933;">;</span>
    <span style="color: #b1b100;">else</span>
        slob_list <span style="color: #339933;">=</span> <span style="color:
#339933;">&</span>free_slob_large<span style="color: #339933;">;</span>
&nbsp;
    ...
&nbsp;
    <span style="color: #202020;">list_for_each_entry</span><span style="color:
#009900;">&#40;</span>sp<span style="color: #339933;">,</span> slob_list<span
style="color: #339933;">,</span> list<span style="color: #009900;">&#41;</span>
    <span style="color: #009900;">&#123;</span>
        ...</pre>
                  </td>
                </tr>
              </table>
            </div>

I think this is a good place to stop since I don&#8217;t want to go
into too many details and because I really look forward to [Dan
Rosenberg&#8217;s talk][22].

Edit: Dan has published a whitepaper to accompany his talk with all
the details on SLOB exploitation; you can find it [here][23].

### Notes

Wrapping this post up, I would like to mention that there are other
slab allocators proposed and implemented for Linux apart from the above three.
[SLQB][24] and [SLEB][25] come to mind, however [as the benevolent dictator has
ruled][26] they are not going to be included in the mainline Linux kernel tree
until one of the existing three has been removed.

Exploitation techniques and methodologies like the ones I mentioned
in this post can be very helpful when you have a vulnerability you&#8217;re
trying to develop a reliable exploit for. However, you should keep in mind that
every vulnerability has its own set of requirements and conditions and
therefore every exploit is a different story/learning experience. Understanding
a bug and actually developing an exploit for it are two very different things.

Thanks to Dan for his comments.

### References

The following resources were not linked directly in the discussion,
but would be helpful in case you want to look more into the subject.

<http://lxr.linux.no/linux+v3.1.6/>  
<http://lwn.net/Articles/229984/>  
<http://lwn.net/Articles/311502/>  
<http://lwn.net/Articles/229096/>  
<http://phrack.org/issues.html?issue=66&#038;id=15#article>  
<http://phrack.org/issues.html?issue=66&#038;id=8#article>

 [1]: https://twitter.com/djrbliss
 [2]: http://immunityinc.com/infiltrate/
 [3]: http://sysc.tl/wp-content/uploads/2011/12/slabs.jpg
 [4]: http://lxr.linux.no/linux+v3.1.6/mm/
 [5]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4759
 [6]: http://thread.gmane.org/gmane.linux.kernel/1108378/
 [7]: http://lxr.linux.no/linux+v3.1.6/mm/slab.c
 [8]: http://home.bn-paf.de/sebastian.haase/kmalloc_exploitation.pdf
 [9]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0424
 [10]: http://phrack.org/issues.html?issue=64&#038;id=6#article
 [11]: http://lxr.linux.no/linux+v3.1.6/mm/slub.c
 [12]: http://lxr.linux.no/linux+v3.1.6/include/linux/mm_types.h#L27
 [13]: http://lxr.linux.no/linux+v3.1.6/mm/slub.c#L3269
 [14]: http://lxr.linux.no/linux+v3.1.6/mm/slub.c#L929
 [15]:
http://www.amazon.com/gp/product/1597494860/ref=as_li_ss_tl?ie=UTF8&#038;tag=oss
042-20&#038;linkCode=as2&#038;camp=1789&#038;creative=390957&#038;creativeASIN=1
597494860
 [16]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1046
 [17]: http://kernelbof.blogspot.com/2009/07/even-when-one-byte-matters.html
 [18]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2959
 [19]: http://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/
 [20]: http://lxr.linux.no/linux+v3.1.6/mm/slob.c
 [21]: http://lxr.linux.no/linux+v3.1.6/mm/slob.c#L321
 [22]: http://immunityinc.com/infiltrate/speakers.html
 [23]: http://vsecurity.com/download/papers/slob-exploitation.pdf
 [24]: http://thread.gmane.org/gmane.linux.kernel/780475
 [25]: http://thread.gmane.org/gmane.linux.kernel.mm/48394/
 [26]: http://thread.gmane.org/gmane.linux.kernel.mm/48515
